# -*- coding: utf-8 -*-
"""
Created on Mon Nov 05 13:05:27 2018

@author: Matthew.Pearlson.CTR
"""

# lxml text code

# read in a template XML document that would pass the schema validation. 
# for now, this is just template for the tes, and  in the future, we could 
# have the template XML generated by the latest XSD in the lib folder.

import os
import sys
        
try:
    from lxml import etree, objectify
except ImportError:
    print ("This script requires the lxml Python library to validate the XML scenario file.")
    print("Download the library here: https://pypi.python.org/pypi/lxml/2.3")
    print("Exiting...")
    sys.exit()
    

# ======================================================================================================================

# define the location of the template globally
# we reverse out the lib folder from the local tools module path

tools_dir = os.path.split(os.path.realpath(__file__))[0]
ftot_program_directory = os.path.split(tools_dir)[0]
xml_template_file_location = os.path.join(ftot_program_directory, "lib", "v5_temp_Scenario.xml")



def repl_old():

    should_quit = False

    xml_file_location = ""
    while not should_quit:
        print ("XML Utility Options")
        print ("-------------------")
        print ("(1) ------ Create new template with defaults")
        print ("(2) ------ Upgrade an old XML")
        print ("(3) ------ Quit....")
        ux_response = get_user_input("enter a selection")
        if ux_response == "1":
            print("XML task")
            # (1) raw_input() on default XML
            # output a fully commented XML template for the user to fill out manually
            xml_file_location = generate_xml()
        elif ux_response == "2":
            # (2) upgrade xml
            # compare an old XML file with a new tool
            xml_file_location = xml_upgrade_tool()
        elif ux_response == "3":
            should_quit = True
        else:
            print("warning: response: {} -- not recognized. please enter a valid value: 1, 2, 3".format(ux_response))

        return xml_file_location
# ======================================================================================================================


def load_scenario_config_file(fullPathToXmlConfigFile):

    if not os.path.exists(fullPathToXmlConfigFile):
        raise IOError("XML Scenario File {} not found at specified location.".format(fullPathToXmlConfigFile))

    if fullPathToXmlConfigFile.rfind(".xml") < 0:
        raise IOError("XML Scenario File {} is not an XML file type.".format(fullPathToXmlConfigFile))

    parser = etree.XMLParser(remove_blank_text=True)
    return etree.parse(fullPathToXmlConfigFile, parser) 

# ==============================================================================


def do_the_upgrades(the_template_etree, the_old_xml_etree):
    
    # load both documents to the lxml etree
    # iterate through the template
    # --------------------------------------------------------------
    item_counter = 0
    for temp_elem in the_template_etree.getiterator():
        item_counter += 1
    
        # check if the temp_element has the .find attribute
        # if it does, then search for the index
        # to '{' char at the end of namespace (e.g. {FTOT}Scenario)
        # if there is no attribute, we continue b/c its probably a comment. 
        if not hasattr(temp_elem.tag, 'find'):
            continue
        clean_temp_elem = clean_element_name(temp_elem)

        # if the text in the element is just white space (ignore it)
        # --------------------------------------------------------------
        if temp_elem.text == "":
            continue
    
        # otherwise, inspect the element.

        # now we are going to iterate through the old XML and try to find a
        # matching records. If we find one, we'll flip the set_flag variable 
        # (intialized below) to True, to indicate we found one. If we get to 
        # the end of the old XML loop and there is no match, we query the user. 
        # ----------------------------------------------------------------------
        set_flag = False

        for old_elem in the_old_xml_etree.getiterator():
            
            # do a little bit of clean up on the namespaces...
            
            # first make sure its not a comment, 
            # by checking if it has the ".find" attribute
            # -------------------------------------------
            if not hasattr(old_elem.tag, 'find'): continue  # (1)
            
            # find the index of the end of the namespace 
            # then clean the name so there are no namespaces 
            # to mess with the compare
            # -------------------------------------------
            clean_old_elem = clean_element_name(old_elem)

            # check the cleaned tags for a match
            # -------------------------------------------
            
            # a matched tag scenario
            if clean_temp_elem == clean_old_elem:
                # get the parent element name
                temp_parent = temp_elem.getparent()
                old_parent = old_elem.getparent()
                # check if the parent Null
                clean_temp_parent = None
                clean_old_parent = None
                if temp_parent is not None:
                    clean_temp_parent = clean_element_name(temp_parent)
                if old_parent is not None:
                    clean_old_parent = clean_element_name(old_parent)

                if clean_temp_parent != clean_old_parent:
                    # if the parents don't match, keep iterating.
                    continue

                # check if there is a "default response"
                # ---------------------------------------
                ux_response = is_a_default_new_tag(clean_temp_elem)
                if ux_response == "":
                    ux_script = "which one do you want keep? enter: old, new, edit, or quit"
                    ux_response = get_user_input(ux_script)
                
                # if not, ask the user which one to keep
                # ---------------------------------------
                if ux_response == "old":
                    temp_elem.text = old_elem.text
                    set_flag = True
                elif ux_response == "new":
                    set_flag = True
                elif ux_response == "edit":
                    temp_elem.text = get_user_input("enter a value press [return]")
                    set_flag = True
                elif ux_response in ["quit", "exit"]:
                    io_error = "user asked to quit...quiting without saving"
                    raise IOError(io_error)
                else:
                    print("warning: '{}' is not a valid input. try again... or quit".format(ux_response))
                
            # a no match scenario.
            # ---------------------
            else:
                continue

        # if at the end of the loop we didnt match an old element 
        # against the new template, get input from the user
        # current default behavior is to keep the
        # new template values as the default
        if not set_flag:
            
            # accept the template element as the default value
            # -------------------------------------------------
            temp_elem.text = temp_elem.text # this doesnt actually do anything
            
            # uncomment to allow the user to specify the new tag
            # ----------------------------------------------------
            #ux_string = "The temp_element {} -- didn't match against the old xml file... it needs a value \n temp_xml value: {}".format(clean_temp_elem, temp_elem.text)
            #temp_elem.text = get_user_input(ux_string)

            # record the change in the log            
            print("setting temp_elem: {} to {}".format(clean_temp_elem, temp_elem.text))
    
    return 

# ==============================================================================


def record_deprecated_elements():
    pass
    # now, check for deprecated elements by looping through the old document
    # for each elemet in the old document
    # check if there is a match in the new document.
    # if there is not, then log it!
    
    
# ==============================================================================


def is_a_default_new_tag(clean_temp_elem):
    old_or_new = ""
    
    default_new_list = [
                        "Scenario_Schema_Version"                        
                        ]
    default_old_list = [
                        "Scenario_Name",
                        "Scenario_Description",
                        "Common_Data_Folder",
                        "Base_Network_Gdb",
                        "Base_RMP_Layer"
                        ]
                        
    if clean_temp_elem in default_new_list: old_or_new = "new"
    else: old_or_new = "old"
        
    return old_or_new

# ==============================================================================


def clean_element_name(element):
    # REMOVE THE NAMESPACE FROM THE FRONT OF THE TAG
    # e.g. {FTOT}Scenario --> Scenario
    # find the index of the end of the namespace 
    # then clean the name so there are no namespaces 
    # to mess with the compare
    #-------------------------------------------
    ns_i = element.tag.find("}")
    return element.tag[ns_i+1:]

# ==============================================================================


def get_user_input(ux_string):
    # ask the user for a XML file please
    print (ux_string)
    user_input = raw_input('--> ')
    print("user_input: {}".format(user_input))
    return user_input

# ==============================================================================


def save_the_new_xml_file(the_temp_etree):
    report_file_dir = False 
    should_quit = False
    while not should_quit:
        report_file_dir = get_user_input("enter a path to save the scenario file")
        
        if os.path.exists(str(report_file_dir)):should_quit = True
        if report_file_dir == "quit": should_quit = True
        if report_file_dir == False: print("warning: report file dir {} not found. enter a new path or type 'quit'".format(report_file_dir))
    
    report_file_name = get_user_input("name of the scenario file")
    if report_file_name .rfind(".xml") < 0:
        report_file_name += ".xml"
    
    report_file = os.path.join(report_file_dir, report_file_name)
    
    with open(report_file, 'wb') as wf:
        print("writing the file: {} ".format(report_file))
        the_temp_etree.write(wf, pretty_print=True)
        print("done writing xml file: {}".format(report_file))
        
    return report_file

# ==============================================================================


def generate_xml():
    # copies the template xml file with default values 
    # from the lib folder to a location the user specifies
    
    the_temp_etree = load_scenario_config_file(xml_template_file_location)
    return save_the_new_xml_file(the_temp_etree)
    

# ==============================================================================


def xml_upgrade_tool():

    CLI_UX_TEMP_XML_PATH = "give me the template please...drag and drop is fine here"

    the_temp_etree = load_scenario_config_file(xml_template_file_location)     
#    # ask the user for a XML file please
#    print ("give me the template please...drag and drop is fine here")
#    the_template_path = raw_input('--> ')
#    print("USER INPUT: the_template_path: {}".format(the_template_path))
#    the_temp_etree = load_scenario_config_file(the_template_path)

    
    # ask the user for a XML file please
    print ("give me the XML to upgrade please...drag and drop is fine here")
    the_old_xml_path = raw_input('--> ')
    print("USER INPUT: the_old_xml_path: {}".format(the_old_xml_path))
    the_old_xml_etree = load_scenario_config_file(the_old_xml_path)
    
    print("about to do the upgrade analysis")
    do_the_upgrades(the_temp_etree, the_old_xml_etree)
    
    print("saving the xml template as a new file")
    return save_the_new_xml_file(the_temp_etree)

# ==============================================================================


def should_quit():
    print "returning to the FTOT Tools REPL"
    return False


# ==============================================================================


menuItems = [
    { "create new template with default values": generate_xml},
    { "upgrade an old XML": xml_upgrade_tool},
    { "exit": should_quit },
]

def repl():
    stay_in_repl = True
    os.system('cls')
    while stay_in_repl:
        print ("XML Tools")
        for item in menuItems:
            print("[" + str(menuItems.index(item)) + "] " + item.keys()[0])
        choice = raw_input(">> ")
        try:
            if int(choice) < 0 : raise ValueError
            # Call the matching function
            stay_in_repl = menuItems[int(choice)].values()[0]()
        except (ValueError, IndexError):
            pass
