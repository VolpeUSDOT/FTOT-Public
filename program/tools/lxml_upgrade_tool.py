# -*- coding: utf-8 -*-
"""
Created on Mon Nov 05 13:05:27 2018

@author: Matthew.Pearlson.CTR
"""

# lxml text code

# Read in a template XML document that would pass the schema validation.
# For now, this is just a template for the test, and in the future, we could 
# have the template XML generated by the latest XSD in the lib folder.

import os
import sys
from six.moves import input
        
try:
    from lxml import etree, objectify
except ImportError:
    print("This script requires the lxml Python library to validate the XML scenario file.")
    print("Download the library here: https://pypi.python.org/pypi/lxml/2.3")
    print("Exiting...")
    sys.exit()
    

# ======================================================================================================================

# Define the location of the template globally
# We reverse out the lib folder from the local tools module path

tools_dir = os.path.split(os.path.realpath(__file__))[0]
ftot_program_directory = os.path.split(tools_dir)[0]
xml_template_file_location = os.path.join(ftot_program_directory, "lib", "v7_temp_Scenario.xml")


# ======================================================================================================================

def load_scenario_config_file(fullPathToXmlConfigFile):

    if not os.path.exists(fullPathToXmlConfigFile):
        raise IOError("XML scenario file {} not found at specified location.".format(fullPathToXmlConfigFile))

    if fullPathToXmlConfigFile.rfind(".xml") < 0:
        raise IOError("XML scenario file {} is not an XML file type.".format(fullPathToXmlConfigFile))

    parser = etree.XMLParser(remove_blank_text=True)
    return etree.parse(fullPathToXmlConfigFile, parser)


# ==============================================================================

def do_the_upgrades(the_template_etree, the_old_xml_etree):
    
    # load both documents to the lxml etree
    # iterate through the template
    # --------------------------------------------------------------
    item_counter = 0
    for temp_elem in the_template_etree.getiterator():
        item_counter += 1
    
        # check if the temp_element has the .find attribute
        # if it does, then search for the index
        # to '{' char at the end of namespace (e.g., {FTOT}Scenario)
        # if there is no attribute, we continue b/c it is probably a comment
        if not hasattr(temp_elem.tag, 'find'):
            continue
        clean_temp_elem = clean_element_name(temp_elem)

        # if the text in the element is just white space, ignore it
        # --------------------------------------------------------------
        if temp_elem.text == "":
            continue
    
        # otherwise, inspect the element

        # Now we are going to iterate through the old XML and try to find a
        # matching record. If we find one, we'll flip the set_flag variable 
        # (intialized below) to True to indicate we found one. If we get to 
        # the end of the old XML loop and there is no match, we query the user.
        # ----------------------------------------------------------------------
        set_flag = False

        for old_elem in the_old_xml_etree.getiterator():
            
            # do a little bit of clean up on the namespaces...
            
            # first make sure it is not a comment
            # by checking if it has the ".find" attribute
            # -------------------------------------------
            if not hasattr(old_elem.tag, 'find'):
                continue
            
            # find the index of the end of the namespace 
            # then clean the name so there are no namespaces
            # to mess with the compare
            # -------------------------------------------
            clean_old_elem = clean_element_name(old_elem)

            # check the cleaned tags for a match
            # -------------------------------------------
            
            # a matched tag scenario
            if clean_temp_elem == clean_old_elem:
                # get the parent element name
                temp_parent = temp_elem.getparent()
                old_parent = old_elem.getparent()
                # check if the parent is Null
                clean_temp_parent = None
                clean_old_parent = None
                if temp_parent is not None:
                    clean_temp_parent = clean_element_name(temp_parent)
                if old_parent is not None:
                    clean_old_parent = clean_element_name(old_parent)

                if clean_temp_parent != clean_old_parent:
                    # if the parents don't match, keep iterating
                    continue

                # check if there is a "default response"
                # ---------------------------------------
                ux_response = is_a_default_new_tag(clean_temp_elem)

                # if not, ask the user which one to keep
                # ---------------------------------------
                if ux_response == "":
                    ux_script = "which one do you want to keep? enter: old, new, edit, or quit"
                    ux_response = get_user_input(ux_script)
                
                if ux_response == "old":
                    temp_elem.text = old_elem.text
                    set_flag = True
                elif ux_response == "new":
                    set_flag = True
                elif ux_response == "edit":
                    temp_elem.text = get_user_input("enter a value then press [return]")
                    set_flag = True
                elif ux_response in ["quit", "exit"]:
                    io_error = "user asked to quit... quitting without saving"
                    raise IOError(io_error)
                else:
                    print("warning: '{}' is not a valid input. try again... or quit".format(ux_response))
                
            # a no match scenario
            # ---------------------
            else:
                continue

        # if at the end of the loop we didn't match an old element
        # against the new template, get input from the user
        # current default behavior is to keep the
        # new template values as the default
        if not set_flag:
            
            # accept the template element as the default value
            # -------------------------------------------------
            temp_elem.text = temp_elem.text #  this doesn't actually do anything
            
            # uncomment to allow the user to specify the new tag
            # ----------------------------------------------------
            # ux_string = "The temp_element {} -- didn't match against the old XML file... it needs a value \n temp_xml value: {}".format(clean_temp_elem, temp_elem.text)
            # temp_elem.text = get_user_input(ux_string)

            # record the change in the log
            print("setting temp_elem: {} to {}".format(clean_temp_elem, temp_elem.text))
    
    return


# ==============================================================================

def record_deprecated_elements():
    pass
    # check for deprecated elements by looping through the old document
    # for each element in the old document
    # check if there is a match in the new document
    # if there is not, then log it

    
# ==============================================================================

def is_a_default_new_tag(clean_temp_elem):
    old_or_new = ""
    
    default_new_list = [
                        "Scenario_Schema_Version"                        
                        ]
    default_old_list = [
                        "Scenario_Name",
                        "Scenario_Description",
                        "Common_Data_Folder",
                        "Base_Network_Gdb",
                        "Base_RMP_Layer"
                        ]

    if clean_temp_elem in default_new_list:
        old_or_new = "new"
    else:
        old_or_new = "old"
        
    return old_or_new


# ==============================================================================

def clean_element_name(element):
    # REMOVE THE NAMESPACE FROM THE FRONT OF THE TAG
    # e.g. {FTOT}Scenario --> Scenario
    # find the index of the end of the namespace 
    # then clean the name so there are no namespaces 
    # to mess with the compare
    ns_i = element.tag.find("}")
    return element.tag[ns_i+1:]


# ==============================================================================

def get_user_input(ux_string):
    # ask the user for a XML file
    print(ux_string)
    user_input = input('--> ')
    print("user_input: {}".format(user_input))
    return user_input


# ==============================================================================

def save_the_new_xml_file(the_temp_etree):
    report_file_dir = False
    should_quit = False
    while not should_quit:
        report_file_dir = get_user_input("enter a directory in which to save the scenario file")
        
        if os.path.exists(str(report_file_dir)):
            should_quit = True
        if report_file_dir == "quit":
            return
        if should_quit == False:
            os.makedirs(report_file_dir)
            should_quit = True
    
    report_file_name = get_user_input("enter a name for the scenario file")
    if report_file_name.rfind(".xml") < 0:
        report_file_name += ".xml"
    
    report_file = os.path.join(report_file_dir, report_file_name)
    
    if os.path.exists(report_file):
        print(report_file + " already exists")
        print("do you want to overwrite this file?")
        overwrite = input('----------------------> ')
        yes_no = False
        while yes_no == False:
            if (overwrite.lower() == 'y' or overwrite.lower()=='yes'):
                yes_no = True
                with open(report_file, 'wb') as wf:
                    print("writing the file: {} ".format(report_file))
                    the_temp_etree.write(wf, pretty_print=True)
                    print("done writing XML file: {}".format(report_file))
                    return report_file
            elif (overwrite.lower() == 'n' or overwrite.lower()=='no'):
                print("not overwriting file, returing to main menu")
                yes_no = True
            else:
                print("invalid input")
                print("do you want to overwrite this file?")
                overwrite = input('----------------------> ')
    else:
        with open(report_file, 'wb') as wf:
            print("writing the file: {} ".format(report_file))
            the_temp_etree.write(wf, pretty_print=True)
            print("done writing XML file: {}".format(report_file))
            return report_file


# ==============================================================================

def generate_xml():
    # copies the template XML file with default values
    # from the lib folder to a location the user specifies
    
    the_temp_etree = load_scenario_config_file(xml_template_file_location)
    return save_the_new_xml_file(the_temp_etree)


# ==============================================================================

def xml_upgrade_tool():
    CLI_UX_TEMP_XML_PATH = "give me the template please... drag and drop is fine here"

    the_temp_etree = load_scenario_config_file(xml_template_file_location)
    # ask the user for a XML file please
    # print("give me the template please... drag and drop is fine here")
    # the_template_path = raw_input('--> ')
    # print("USER INPUT: the_template_path: {}".format(the_template_path))
    # the_temp_etree = load_scenario_config_file(the_template_path)
    
    # ask the user for a XML file
    print("give me the XML to upgrade please... drag and drop is fine here")
    the_old_xml_path = input('--> ').strip('\"')
    print("USER INPUT: the_old_xml_path: {}".format(the_old_xml_path))
    the_old_xml_etree = load_scenario_config_file(the_old_xml_path)
    
    print("about to do the upgrade analysis")
    do_the_upgrades(the_temp_etree, the_old_xml_etree)
    
    print("saving the XML template as a new file")
    return save_the_new_xml_file(the_temp_etree)


# ==============================================================================

def should_quit():
    print("returning to the FTOT Tools menu")
    return False


# ==============================================================================

menuItems = [
    {"create new template with default values": generate_xml},
    {"upgrade an old XML": xml_upgrade_tool},
    {"exit": should_quit}
]

def repl():
    stay_in_repl = True
    os.system('cls')
    while stay_in_repl:
        print("XML Tools")
        for item in menuItems:
            print("[" + str(menuItems.index(item)+1) + "] " + list(item.keys())[0])
        choice = input(">> ")
        try:
            if int(choice) < 0:
                raise ValueError
            # Call the matching function
            stay_in_repl = list(menuItems[int(choice)-1].values())[0]()
        except (ValueError, IndexError):
            pass
